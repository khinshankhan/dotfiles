#+STARTUP: overview
#+PRIORITIES: A D B

** Helpful Libraries

   These are just cool libraries I’d like to use during my configuration, or many of the packages use them.

   #+begin_src emacs-lisp
(use-package dash-functional
  :demand t)
(use-package f
  :demand t)
(use-package s
  :demand t)
   #+end_src

** Personal Variables

   Me, myself, and I. These are personal preferences for emacs file structure.

   #+begin_src emacs-lisp
(defconst custom-file (concat user-emacs-directory "custom.el"))
(defconst shan--settings-path (concat user-emacs-directory "personal/settings.el")
  "Path to personal settings meant not be public (api keys and stuff).")
(defconst shan--settings-exist? (file-exists-p shan--settings-path)
  "Checks if shan--settings-path exists.")
(when shan--settings-exist?
  (load-file shan--settings-path))
   #+end_src

   Check git access.

   #+begin_src emacs-lisp
(defconst shan--gh-access (string-prefix-p "Hi" (shell-command-to-string "ssh -T git@github.com"))
  "Checks if Emacs has ssh access for GitHub (inherited path).")
(defconst shan--gl-access (string-prefix-p "Welcome" (shell-command-to-string "ssh -T git@gitlab.com"))
  "Checks if Emacs has ssh access for GitLab (inherited path).")

(if (and shan--gh-access shan--gl-access)
    (setq straight-vc-git-default-protocol 'ssh)
  (message "GH ACCESS:")
  (print shan--gh-access)
  (message "GL ACCESS:")
  (print shan--gl-access))
   #+end_src

   A couple of booleans so we don’t have to check everytime.

   #+begin_src emacs-lisp
(defconst shan--personal? (-contains? '("shan" "faux-thunkpad") (system-name))
  "Checks if the laptop is owned by me (which helps with permissions and logical programs I may have).")
(defconst shan--is-mac? (memq window-system '(mac ns))
  "Checks if computer is a mac.")
   #+end_src

   Personal favored variables

   #+begin_src emacs-lisp
(defconst shan--preferred-logo (concat user-emacs-directory "personal/nezuko-emacs.png")
  "Preferred logo for dashboard startup. If not found, use default.")
(defconst shan/elfeed-file (concat user-emacs-directory "personal/elfeed.org"))
(defconst shan/elfeed-db (concat user-emacs-directory "personal/elfeeddb"))
   #+end_src

   Just variables for machines

   #+begin_src emacs-lisp
(defconst shan/python-executable "python3")
(defconst shan/ipython-executable "ipython3")

(defconst shan--home-row
  (if shan--personal?
      '(?a ?r ?s ?t ?n ?e ?i ?o)
    '(?a ?s ?d ?f ?j ?k ?l ?\;)))
   #+end_src

   Shorthands

   #+begin_src emacs-lisp
(defconst shan--dart-path "/opt/flutter/bin/cache/dart-sdk/")
(defconst shan--flutter-path "/opt/flutter/")
(defconst shan--plantuml-path "/usr/share/java/plantuml/plantuml.jar")
(defconst shan--kotlin-path "/home/shan/kotlin-language-server/server/build/install/server/bin/kotlin-language-server")
   #+end_src

** TODO General Functions

   Personal functions, some packages are reliant on these, so it goes on top. Working on credit for people not
   mentioned in preface and significant enough. People should be cited even if the function was modified. Functions
   are split into… “sensible” groups. Note, they’re prefixed with shan/ over other prefixes because I needed
   ‘namespaces’ and I like auto completing any ‘custom’ function off of this one prefix instead of remembering
   more.

   #+begin_src emacs-lisp
(defun shan/do-nothing ()
  "Do nothing."
  (interactive)
  nil)

(defun shan/before (to-call-before f)
  "Run TO-CALL-BEFORE then run F."
  (funcall to-call-before)
  (funcall f))

(defun shan/after (to-call-after f)
  "Run F then run TO-CALL-AFTER."
  (funcall f)
  (funcall to-call-after))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/refresh-buffer ()
  "Refresh the current buffer."
  (interactive)
  (revert-buffer :ignore-auto :noconfirm))

(defun shan/scratch ()
  "Create a new scratch buffer to work in.  (could be *scratch* - *scratchX*)."
  (interactive)
  (let ((n 0) bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (lisp-interaction-mode)))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/sudo-edit (file-name)
  "Like find file, but opens FILE-NAME as root."
  (interactive "FSudo Find File: ")
  (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
    (find-file tramp-file-name)))

(defun shan/delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))

(defun shan/rename-this-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (progn
      (when (file-exists-p filename)
        (rename-file filename new-name 1))
      (set-visited-file-name new-name)
      (rename-buffer new-name))))

(defun shan/browser-current-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))

(defun shan/path-copy ()
  "Copy the current file path to kill ring."
  (interactive)
  (kill-new buffer-file-name))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/fill-or-unfill ()
  "Fill or unfill based on the previous command."
  (interactive)
  (let ((fill-column
         (if (eq last-command 'endless/fill-or-unfill)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (call-interactively #'fill-paragraph)))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/add-list-to-list (to-list from-list &optional append compare-fn)
  "Add all elements from FROM-LIST to TO-LIST.  APPEND and COMPARE-FN work as they in `add-to-list'."
  (dolist (elem from-list)
    (add-to-list to-list elem append compare-fn))
  to-list)

(defun shan/copy-hooks-to (from-hook to-hook)
  "Copies one list of hooks to another, without the weird nonc circular list problem"
  (dolist (hook from-hook)
    (add-hook to-hook hook)))
   #+end_src

   #+begin_src emacs-lisp
(defmacro shan--no-hook (f hooks)
  "Call function F while temporarily removing HOOKS."
  `(lambda (&rest args)
     (let ((tbl (cl-loop for hook in ,hooks collect `(,(gensym) . ,hook))))
       (prog2
           (dolist (pair tbl)
             (eval `(setq ,(car pair) ,(cdr pair)))
             (eval `(setq ,(cdr pair) nil)))
           (apply ,f args)
         (dolist (pair tbl)
           (eval `(setq ,(cdr pair) ,(car pair))))))))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/vanilla-save ()
  "Save file without any hooks applied."
  (interactive)
  (funcall (shan--no-hook 'save-buffer '(before-save-hook after-save-hook))))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/edit-config ()
  "Edit the configuration file."
  (interactive)
  (find-file (concat user-emacs-directory "config.org")))

(defun shan/org-toc (&optional shan/file-name)
  "A nice search utility for org headers in a direcory."
  (interactive)
  (unless shan/file-name
    (setq shan/file-name (read-directory-name "Directory name: ")))
  (let ((files (f-entries shan/file-name (lambda (f) (f-ext? f "org")) t))
        (headlines '())
        choice)
    (loop for file in files do
          (with-temp-buffer
            (insert-file-contents file)
            (goto-char (point-min))
            (while (re-search-forward org-heading-regexp nil t)
              (cl-pushnew (list
                           (format "%-80s (%s)"
                                   (match-string 0)
                                   (file-name-nondirectory file))
                           :file file
                           :position (match-beginning 0))
                          headlines))))
    (setq choice
          (completing-read "Headline: " (reverse headlines)))
    (find-file (plist-get (cdr (assoc choice headlines)) :file))
    (goto-char (plist-get (cdr (assoc choice headlines)) :position))))
   #+end_src

   This bit will require Magit and it's a bit dumb, but it's proven to be quite useful.

   #+begin_src emacs-lisp
(defun shan/git-url-handler (url)
  "Hacky fix, if URL is ssh url, it will make it into https url or else return as is."
  (if (string-prefix-p "git" url)
      (concat "https://github.com/" (substring url 15))
    url))

(defun shan/browse-git-repo ()
  "Open repository with `browse-url' if applicable"
  (interactive)
  (let ((url (shan/git-url-handler (magit-get "remote.origin.url"))))
    (if (string-prefix-p "http" url)
        (browse-url url)
      (message "No remote repository at point!"))))
   #+end_src

   #+begin_src emacs-lisp
(defun shan/call-keymap (map &optional prompt)
  "Read a key sequence and call the command it's bound to in MAP."
  (let* ((help-form `(describe-bindings ,(vector map)))
         (key (read-key-sequence prompt))
         (cmd (lookup-key map key t)))
    (if (functionp cmd) (call-interactively cmd)
      (user-error "%s is undefined" key))))

(defun shan/exec-call-keymap (keymap prompt)
  "Executes `shan/call-keymap'"
  (interactive)
  (shan/call-keymap keymap prompt))
   #+end_src

   use-package/ straight customization. A lot of inspiration from Doom Emacs,

   #+begin_src emacs-lisp
(defmacro package! (name &rest args)
  "Like `use-package', but shorter and cooler.
NAME and ARGS are as in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :straight t
     ,@args))

(defmacro feature! (name &rest args)
  "Like `use-package', but with `straight-use-package-by-default' disabled.
NAME and ARGS are as in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :straight nil
     ,@args))

(defmacro require! (name &rest args)
  "Like `use-package', but automagically requires the package as well. Useful for antiquated packages.
NAME and ARGS are as in `use-package'."
  (declare (indent defun))
  `(package! ,name
     :init
     (message "hi")
     (require ',name)
     ,@args))
   #+end_src
