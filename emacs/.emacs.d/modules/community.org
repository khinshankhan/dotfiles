#+STARTUP: overview
#+PRIORITIES: A D B

** TODO Browser

   Control how links and browser-url-generic function works (also for links).

   #+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic)

(cond((executable-find "firefox") (setq browse-url-generic-args '("-private")
                                        browse-url-firefox-program "firefox"
                                        browse-url-generic-program "firefox"))
     ((executable-find "chromium") (setq browse-url-generic-args '("-incognito")
                                         browse-url-chromium-program "chromium"
                                         browse-url-generic-program "chromium"))
     ((executable-find "google-chrome") (setq browse-url-generic-args '("-incognito")
                                              browse-url-chrome-program "google-chrome"
                                              browse-url-generic-program "chrome")))
   #+end_src

** carbon.now.sh

   You select a region and press the function, and viola, a pretty picture of your code to share. Using a fork I control for some nice features.

   #+begin_src emacs-lisp
(use-package carbon-now-sh
  :straight (:host github :repo "spicyriceball/carbon-now-sh.el"))
   #+end_src

** Discord Rich Presence

   It's cool when Discord is installed and opened (almost always at home). It would probably be better if I check
   =after-init= if a discord process is running once, or else manually enable the mode.

   #+begin_src emacs-lisp
(use-package elcord
  :if (and (executable-find "discord") shan--personal?)
  :config
  (setq elcord-use-major-mode-as-main-icon t)
  :init
  (elcord-mode))
   #+end_src

** Elfeed

   #+begin_src emacs-lisp
(defun shan/elfeed-sync-database ()
  "Wrapper to load the elfeed db from disk and update it"
  (interactive)
  (elfeed-db-load)
  (elfeed-update))

(defun shan/elfeed-load-db-and-open ()
  "Wrapper to load the elfeed db from disk before opening"
  (interactive)
  (shan/elfeed-sync-database)
  (elfeed)
  (elfeed-search-update--force))

;;write to disk when quiting
(defun bjm/elfeed-save-db-and-bury ()
  "Wrapper to save the elfeed db to disk before burying buffer"
  (interactive)
  (elfeed-db-save)
  (quit-window))

(defun elfeed-mark-all-as-read ()
  "Wrapper to mark all elfeed entries in a buffer as read"
  (interactive)
  (mark-whole-buffer)
  (elfeed-search-untag-all-unread))

(use-package elfeed
  :if (file-exists-p shan/elfeed-file)
  :bind
  (:map elfeed-search-mode-map
        ("q" . shan/elfeed-save-db-and-bury)
        ("Q" . shan/elfeed-save-db-and-bury)
        ("m" . elfeed-toggle-star)
        ("M" . elfeed-toggle-star))
  :custom
  (elfeed-db-directory shan/elfeed-db)
  :config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'star)))

(use-package elfeed-org
  :after (elfeed)
  :custom
  (rmh-elfeed-org-files (list shan/elfeed-file))
  :config
  (elfeed-org))

(use-package elfeed-goodies
  :after (elfeed elfeed-org)
  :config
  (elfeed-goodies/setup))
   #+end_src

** Emojify

   Utilizing [[https://github.com/iqbalansari/emacs-emojify][this package]], we finally have colorful emoji. The unicode emoji are
   still very meh. Will probably make my own images and source them. May end up
   moving this into a different file them.

   #+begin_src emacs-lisp
(use-package emojify
  :init
  (setq emojify-user-emojis '(("ðŸ§š" . (("name" . "Fairy")
                                       ("image" . "~/.emacs.d/emoji/fairy.png")
                                       ("style" . "unicode")))))
  (setq emojify-point-entered-behaviour 'uncover)
  (setq emojify-show-help nil)
  (global-emojify-mode)
  (emojify-set-emoji-data))
   #+end_src

** TODO Key Frequency

   For later use, when I try to finally optimize my workflow + ergonomics.

   #+begin_src emacs-lisp
(use-package keyfreq
  :config
  (keyfreq-mode t)
  ;;(keyfreq-autosave-mode 1)
  )
   #+end_src

** TODO SICP

   If I have the book, I've lost an excuse to not read it... hopefully. Might as well make this section TODO too...

   #+begin_src emacs-lisp
(use-package sicp)
   #+end_src

** Wakatime

   Monitor my coding activity. Remember to set =wakatime-api-key= in =personal/settings.el=.

   #+begin_src emacs-lisp
(use-package wakatime-mode
  :if (and (executable-find "wakatime") (boundp 'wakatime-api-key))
  :config
  (setq wakatime-cli-path (executable-find "wakatime"))
  (global-wakatime-mode))
   #+end_src
